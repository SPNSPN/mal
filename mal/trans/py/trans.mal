(load "mal/interpreter.mal")

(define shift-indent
  (lambda (codes)
	(map (lambda (line) (sprint "\t" line)) codes)))

(! let ((counter -1))
   (define trans::py::gen-lambda-name
	 (lambda () (do (setq counter (+ counter 1))
				  	(sprint "_sys_lambda_" counter)))))

(define trans::py::sys-var "_sys_var")

(define trans::py::env ())
(define regist
  (lambda (sym fn)
	`(! push trans::py::env (cons ,sym ,fn))))

(! regist if (lambda (pred then else)
			   (append (trans::py::encode pred)
					   (list (sprint "if " trans::py::sys-var ":"))
					   (shift-indent (trans::py::encode then))
					   (list "else:")
					   (shift-indent (trans::py::encode else)))))


(! let ((regist (lambda (sym body)
				  `(! push trans::py::env (cons ,sym (lambda (args) ,body))))))
   (do (! regist if (sprint "if " (trans::py::encode (car args) 0) ":\n"
							(trans::py::encode (car (cdr args)) 1) "\n"
							"else:\n"
							(trans::py::encode (car (cdr (cdr args))) 1)))
	   (! regist lambda ())
	   (! regist define ())
	   (! regist setq ())
	   (! regist quote ())
	   (! regist do ())
	   (! regist and ())
	   (! regist or ())
	   (! regist quasiquote ())
	   (! regist environment ())
	   (! regist ! ())
	   (! regist catch ())
	   ))


(define trans::py::encode
  (! let ((var-counter 0))
	 (lambda (expr level)
	   (! case (type expr)
		  ('<nil> "False"
		   '<inum> (sprint expr)
		   '<fnum> (sprint expr)
		   '<strn> expr
		   '<symb> (sprint expr)
		   '<cons> (! let ((proc (car expr)))
					  (! aif (assocdr trans::py::env proc)
						 (it (cdr expr))
						 (sprint proc "("
								 (join (map (lambda (arg)
											  (trans::py::encode arg nlevel))
											(cdr expr)) ", ") ")"))))))))

